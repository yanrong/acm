比如有一个字符串 “0123456789ABCDEF”，转为zigzag

当 n = 2 时：
0 2 4 6 8 A C E
1 3 5 7 9 B D F

当 n = 3 时：
0   4   8   C
1 3 5 7 9 B D F
2   6   A   E

当 n = 4 时：
0    6    C
1  5 7  B D
2 4  8 A  E
3    9    F

思路：
  我们发现，除了第一行和最后一行没有中间形成之字型的数字外，其他都有，而首位两行中相邻两个元素的index之差跟行数是相关的，为 2nRows - 2, 根据这个特点，我们可以按顺序找到所有的黑色元素在元字符串的位置，将他们按顺序加到新字符串里面。对于红色元素出现的位置也是有规律的，每个红色元素的位置为 j + 2nRows-2 - 2i, 其中，j为当前列数，i为当前行数。 比如当n = 4中的那个红色5，它的位置为 1 + 24-2 - 2*1 = 5，为原字符串的正确位置。当我们知道所有黑色元素和红色元素位置的正确算法，我们就可以一次性的把它们按顺序都加到新的字符串里面。代码如下：

/*n=numRows
Δ=2n-2    0                           2n-2                           4n-4
Δ=        1                     2n-3  2n-1                    4n-5   4n-3
Δ=        2               2n-4        2n                 4n-6         .
Δ=        .             .               .               .             .
Δ=        .       n+1                 .           3n-1                .
Δ=        n-2   n                     3n-4    3n-2                   5n-6
Δ=2n-2    n-1                         3n-3                           5n-5
*/
两列之间的差为2n-2（n为行号）”之“字形中间的差距随着行号的变化为：
2n - 2		第0行 
2n - 2 - 4	第1行
2n - 2 - 6  第2行
刚好构成2n -2 - 2i (i = 0 ...)
两列之间的差为2n-2（n为行号），其中除第0行和第n-1行，其余都有“之”字形，如第1行的2n-3，然而两列间差不变，仍为2n-2.中间量的公式为：

  +2（n-1-1）       +2*1
1-----------2n-3----------2n
即第一步+2（n-1-i），第二步+2*i，i为行号。 ( 倒V的形状是一个反的公式，2*i ,因为 2(n - 1 - i) 是在求“之”字形中第字符，两列直接的差距是固定2n -2 所以需要回退 2i）


