使用公式 x ^ {a + b} = x ^ a * x ^ bx ，我们可以将 n 看做一系列正整数之和，n = ∑ bi。如果我们可以很快得到 x ^ bi 的结果，计算 x ^ n的总时间将被降低。


我们可以使用 n 的二进制表示来更好的理解该问题。使 n 的二进制从最低位 (LSB) 到最高位 (MSB) 表示为b_1, b_2, ..., b_limit。对于第 i 位为，如果 b_i = 1意味着我们需要将结果累乘上 x ^ {2 ^ i}

这似乎不能有效率上的提升，因为 ∑ b_i * 2 ^ i = n 但是使用上面提到的公式 (x ^ n) ^ 2 = x ^ {2 * n}，我们可以进行改进。初始化 x ^ 1 = x ，对于每一个 $ i > 1$ ，我们可以在一步操作中使用 x ^ {2 ^ {i - 1}}来得到 x ^ {2 ^ i}x。由于 b_i的个数最多为 O(logn) ，我们可以在 O(logn) 的时间内得到所有的 x ^ {2 ^ i}x 。在那之后，对于所有满足 b_i =1 的 i，我们可以用结果累乘 x ^ {2 ^ i}。这也只需要 O(logn) 的时间。

n可以表示为 n = kn * 2^n + kn-1 * 2^(n-1) + .... + k1 * 2^0 系数 kn 到 K1 的值为{0,1}， 可以简化为((k1*2^1 + k2)*2^1 +k3) .....)*2^1 + kn)*2^1
编程构思“
 最小单位为(k1*2^1 + k2)*2^1  k1 和 k2的取值为0 或者 1，由此可以得出，如果系数有效要多加一个，每次幂指数增加2，自身相乘
作者：LeetCode

