这个问题可以通过动态规划解决。我们定义一个 \text{dp}dp 数组，其中第 ii 个元素表示以下标为 ii 的字符结尾的最长有效子字符串的长度。我们将 \text{dp}dp 数组全部初始化为 0 。现在，很明显有效的子字符串一定以 \text{‘)’}‘)’ 结尾。这进一步可以得出结论：以 \text{‘(’}‘(’ 结尾的子字符串对应的 \text{dp}dp 数组位置上的值必定为 0 。所以说我们只需要更新 \text{‘)’}‘)’ 在 \text{dp}dp 数组中对应位置的值。

为了求出 \text{dp}dp 数组，我们每两个字符检查一次，如果满足如下条件

\text{s}[i] = \text{‘)’}s[i]=‘)’ 且 \text{s}[i - 1] = \text{‘(’}s[i−1]=‘(’ ，也就是字符串形如``……()"‘‘……()"，我们可以推出：

\text{dp}[i]=\text{dp}[i-2]+2
dp[i]=dp[i−2]+2

我们可以进行这样的转移，是因为结束部分的 "()" 是一个有效子字符串，并且将之前有效子字符串的长度增加了 2 。

\text{s}[i] = \text{‘)’}s[i]=‘)’ 且 \text{s}[i - 1] = \text{‘)’}s[i−1]=‘)’，也就是字符串形如 ``.......))"‘‘.......))" ，我们可以推出：
如果 \text{s}[i - \text{dp}[i - 1] - 1] = \text{‘(’}s[i−dp[i−1]−1]=‘(’ ，那么

\text{dp}[i]=\text{dp}[i-1]+\text{dp}[i-\text{dp}[i-1]-2]+2
dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2

这背后的原因是如果倒数第二个 \text{‘)’}‘)’ 是一个有效子字符串的一部分（记为 sub_ssub 
s
​	
 ），对于最后一个 \text{‘)’}‘)’ ，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 \text{‘(’}‘(’ ，它的位置在倒数第二个 \text{‘)’}‘)’ 所在的有效子字符串的前面（也就是 sub_ssub 
s
​	
  的前面）。因此，如果子字符串 sub_ssub 
s
​	
  的前面恰好是 \text{‘(’}‘(’ ，那么我们就用 22 加上 sub_ssub 
s
​	
  的长度（\text{dp}[i-1]dp[i−1]）去更新 \text{dp}[i]dp[i]。除此以外，我们也会把有效子字符串 ``(,sub_s,)"‘‘(,sub 
s
​	
 ,)"之前的有效子字符串的长度也加上，也就是加上 \text{dp}[i-\text{dp}[i-1]-2]dp[i−dp[i−1]−2] 。

