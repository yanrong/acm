#include <vector>
#include <unordered_map>
#include <set>
#include <algorithm>
using std::sort;
using std::vector;
using std::unordered_map;
using std::set;

class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ret;
        vector<int> tmp;
        //sort the number, for cut redundante
        sort(candidates.begin(), candidates.end());
        backTrace(ret, candidates, tmp, 0, target);
        return ret;
    }

    void backTrace(vector<vector<int>>& ret, vector<int>& candidates, vector<int> tmp, int pos, int target){
        if(target == 0){
            ret.push_back(tmp);//if we get a valid result, store it
            return; //return immediately
        }

        for(int i = pos; i < candidates.size() && candidates[i] <= target; i++){
            tmp.push_back(candidates[i]);
            //generate much back trace that cadidates[i] is less equal target 
            backTrace(ret, candidates, tmp, i, target - candidates[i]);
            /**
            *why need pop the top element in stack, just imagine this is the last recurse(reach leaf node)
            *we need go to parent(pop the top) and recurse the other sibling node, next loop indace i had 
            *been pointe to next element in candidates, perfectly simulate the whole backtrace. 
            **/
            tmp.pop_back();
        }
    }
    //dp programming tooooo slow
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
	    unordered_map<int, set<vector<int>>>dict;
        vector<vector<int>>ans;

	    for (int i = 1; i <= target; i++){
            //scan every element in candidates
	        for (int it : candidates){ 
                //type i - i 
	    	    if (i == it){ 
                    dict[i].insert(vector<int>{it});
                }else if (it < i){
                    //if now target i is greate the number in candidates
                    //the present valid combination must be generated by the all previous combination
	    	        //scan each combine in the previous one 
                    for (auto ivec : dict[i - it]) {
	    	    	    ivec.push_back(it); // recorder candidates[i]
	    	    	    sort(ivec.begin(), ivec.end()); // rearrange result
                        //if it is unique, store it set
	    	    	    if(dict[i].count(ivec) == 0) dict[i].insert(ivec);
	    	        }
                }
            }
        }
	    //the last set has been try all combination, and add the unique result, get it
	    for (auto it : dict[target]) ans.push_back(it);
	    return ans;
    }
};